{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"landing.html","text":"About CaDoodle What is CaDoodle? CaDoodle is a local drag-and-drop CAD application for Linux, Windows, Mac and ChromeOS. Users models are stored on their own computer, and the application runs without an internet connection. Inspiration CaDoodle is inspired by TinkerCAD. The workflow of TinkerCAD is an excellent experience for novice users of CAD: Drag and drop shape Group and ungroup Solid and Hole status Undo of operations Stretch and move handles Library of examples Nearest Surface snapping However, this workflow suffers from a few fundamental problems: Web based UI means it is enclosed by whomever runs the server Subscription model is precarious (Autodesk is not known as a reliable partner for free tools over time) Proprietary source files limit sharing, collaboration, and reproducability Solution This application is Java based and uses BowerStudio as the CAD kernel. All scripts will be compatible BowlerStudio scripts. UI will be laid out in SceneBuilder / JavaFX. OpenJDK 17 Hardware Requirements 4 GB of RAM is required The following platforms will be targeted: Windows Mac OS (ARM) Linux Ubuntu (.deb and AppImage) ChromeOS The following platforms will not be targeted: Android iOS Chrome OS Instructions Linux is off by default. You can turn it on any time from Settings. On your Chromebook, at the bottom right, select the time. Select Settings and then About ChromeOS and then Developers. Next to \"Linux development environment,\" select Set up. Follow the on-screen instructions. Setup can take 10 minutes or more. A terminal window opens. You have a Debian environment. You can run Linux commands, install more tools using the APT package manager, and customize your shell. Next download the ChromeOS .deb installer here Finally, double-click on the .deb to install CaDoodle. You can now launch CaDoodle from the applications launcher window. (If possible on your hardware) Enable GPU acceleration via these instructions: (Source: https://www.aboutchromebooks.com/chrome-flags-crostini-gpu-support/ ) Enabling GPU acceleration for Linux applications on Chrome OS significantly enhances performance for demanding tasks such as gaming, 3D modeling, and hardware-accelerated video rendering. This guide provides a complete step-by-step approach to activating the chrome://flags/#crostini-gpu-support flag, helping your Linux environment utilize GPU resources efficiently. What Is chrome://flags/#crostini-gpu-support? Crostini is Chrome OS\u2019s built-in feature that lets users run Linux applications inside a secure container using select Chrome Flags. By default, these applications rely on CPU-based rendering. However, when GPU acceleration is enabled via the Crostini GPU Support flag, it offloads rendering to your Chromebook\u2019s GPU, improving performance, responsiveness, and battery efficiency during intensive tasks. Prerequisites Before enabling GPU support for Linux apps, confirm that your system meets the following criteria: Chrome OS Version: Your Chromebook must run Chrome OS 76 or newer. Crostini Enabled: Linux (Beta) must be turned on in system settings. Hardware Support: Your Chromebook must support GPU virtualization. Steps to Enable Crostini GPU Support 1. Access Chrome Flags Open the Chrome browser. Type chrome://flags in the address bar and hit Enter. Locate the Crostini GPU Support Flag In the flags search bar, type: Crostini GPU Support Or go directly to: chrome://flags/#crostini-gpu-support Enable the Flag Next to the Crostini GPU Support flag, click the dropdown and select Enabled. Restart Your Chromebook A prompt will appear at the bottom of the browser. Click Restart to apply the changes. Steps to Enable Crostini GPU Support Verifying GPU Acceleration in Linux To confirm that GPU acceleration is enabled: Open the Linux Terminal. Run the following commands: sudo apt-get update sudo apt-get install mesa-utils glxinfo -B Check for the line: OpenGL renderer string: Mesa DRI\u2026 If the GPU is being utilized, your actual GPU name will appear instead of \u201cllvmpipe.\u201d Additional Developer Flags You Might Find Useful 1. chrome://flags/#enable-force-dark Enable dark mode for all web content, even if a site doesn\u2019t support it. Especially useful for developers testing UI accessibility under dark environments. Use case: Enables CSS overrides to simulate a dark theme sitewide. 2. chrome://flags/#allow-insecure-localhost Allows Chrome to load insecure content (HTTP) from localhost during development without blocking or warning. Ideal for testing local APIs or self-signed HTTPS certificates. Use case: Running local development environments without needing valid SSL certificates. 3. chrome://flags/#ash-debug-shortcuts Activates developer keyboard shortcuts in Chrome OS. Great for debugging UI components, window managers, or testing multiple screen setups in dev environments. Use case: Chrome OS app development and layout testing on Chrome devices. 4. chrome://flags/#enable-command-line-on-non-rooted-devices This flag enables command-line access on non-rooted Android devices, facilitating debugging for mobile web developers using remote debugging or ADB. Use case: Simulating mobile interactions and terminal access in development workflows. History As an elementary school technology teacher, TinkerCAD provided easy to use on-ramps for students as young as 2nd grade. I spent the 23/24 school year teaching with TinkerCAD and found myself increasingly upset by the limitations and constraints of TinkerCAD. First and foremost, the fact of the CAD models sources being entirely unavailable. The \"Tinkercad source\" is actually entries in the Autodesk servers database. With no option to access those actual sources, students are tied entirely to the tinkercad website. The first real problem came when a student made a model in 5th grade that was so complex that the Tinkercad site crashed. The model was not recoverable, and the student that had done all of that extra work to add detail to his model lost everything. This experience started me thinking about how this could be made better for the students. The next major problem came when another student wanted to do CAD work on her ride home (which due to bus schedules took over an hour each day). She wanted to keep designing things, but without an internet connection she was unable to do any work. Finally i began to contemplate the pedagogical damage being done by teaching students a skill that is only accessible to them as mediated by a company. I began to feel a deep sense of unease that the skills of my students were increasingly being trapped behind a paywall. My solution was to make a locally installed application, that used an open file format that is stored locally on the disk, and that had access to the full resources of the computer the application was running on. In July 2024 I began work in earnest on CaDoodle. In April 2025 I hit a level of feature completeness to open it up for Beta testing.","title":"About CaDoodle CAD"},{"location":"landing.html#about-cadoodle","text":"","title":"About CaDoodle"},{"location":"landing.html#what-is-cadoodle","text":"CaDoodle is a local drag-and-drop CAD application for Linux, Windows, Mac and ChromeOS. Users models are stored on their own computer, and the application runs without an internet connection.","title":"What is CaDoodle?"},{"location":"landing.html#inspiration","text":"CaDoodle is inspired by TinkerCAD. The workflow of TinkerCAD is an excellent experience for novice users of CAD: Drag and drop shape Group and ungroup Solid and Hole status Undo of operations Stretch and move handles Library of examples Nearest Surface snapping However, this workflow suffers from a few fundamental problems: Web based UI means it is enclosed by whomever runs the server Subscription model is precarious (Autodesk is not known as a reliable partner for free tools over time) Proprietary source files limit sharing, collaboration, and reproducability","title":"Inspiration"},{"location":"landing.html#solution","text":"This application is Java based and uses BowerStudio as the CAD kernel. All scripts will be compatible BowlerStudio scripts. UI will be laid out in SceneBuilder / JavaFX. OpenJDK 17","title":"Solution"},{"location":"landing.html#hardware-requirements","text":"4 GB of RAM is required The following platforms will be targeted: Windows Mac OS (ARM) Linux Ubuntu (.deb and AppImage) ChromeOS The following platforms will not be targeted: Android iOS","title":"Hardware Requirements"},{"location":"landing.html#chrome-os-instructions","text":"Linux is off by default. You can turn it on any time from Settings. On your Chromebook, at the bottom right, select the time. Select Settings and then About ChromeOS and then Developers. Next to \"Linux development environment,\" select Set up. Follow the on-screen instructions. Setup can take 10 minutes or more. A terminal window opens. You have a Debian environment. You can run Linux commands, install more tools using the APT package manager, and customize your shell. Next download the ChromeOS .deb installer here Finally, double-click on the .deb to install CaDoodle. You can now launch CaDoodle from the applications launcher window. (If possible on your hardware) Enable GPU acceleration via these instructions: (Source: https://www.aboutchromebooks.com/chrome-flags-crostini-gpu-support/ ) Enabling GPU acceleration for Linux applications on Chrome OS significantly enhances performance for demanding tasks such as gaming, 3D modeling, and hardware-accelerated video rendering. This guide provides a complete step-by-step approach to activating the chrome://flags/#crostini-gpu-support flag, helping your Linux environment utilize GPU resources efficiently. What Is chrome://flags/#crostini-gpu-support? Crostini is Chrome OS\u2019s built-in feature that lets users run Linux applications inside a secure container using select Chrome Flags. By default, these applications rely on CPU-based rendering. However, when GPU acceleration is enabled via the Crostini GPU Support flag, it offloads rendering to your Chromebook\u2019s GPU, improving performance, responsiveness, and battery efficiency during intensive tasks. Prerequisites Before enabling GPU support for Linux apps, confirm that your system meets the following criteria: Chrome OS Version: Your Chromebook must run Chrome OS 76 or newer. Crostini Enabled: Linux (Beta) must be turned on in system settings. Hardware Support: Your Chromebook must support GPU virtualization. Steps to Enable Crostini GPU Support 1. Access Chrome Flags Open the Chrome browser. Type chrome://flags in the address bar and hit Enter. Locate the Crostini GPU Support Flag In the flags search bar, type: Crostini GPU Support Or go directly to: chrome://flags/#crostini-gpu-support Enable the Flag Next to the Crostini GPU Support flag, click the dropdown and select Enabled. Restart Your Chromebook A prompt will appear at the bottom of the browser. Click Restart to apply the changes. Steps to Enable Crostini GPU Support Verifying GPU Acceleration in Linux To confirm that GPU acceleration is enabled: Open the Linux Terminal. Run the following commands: sudo apt-get update sudo apt-get install mesa-utils glxinfo -B Check for the line: OpenGL renderer string: Mesa DRI\u2026 If the GPU is being utilized, your actual GPU name will appear instead of \u201cllvmpipe.\u201d Additional Developer Flags You Might Find Useful 1. chrome://flags/#enable-force-dark Enable dark mode for all web content, even if a site doesn\u2019t support it. Especially useful for developers testing UI accessibility under dark environments. Use case: Enables CSS overrides to simulate a dark theme sitewide. 2. chrome://flags/#allow-insecure-localhost Allows Chrome to load insecure content (HTTP) from localhost during development without blocking or warning. Ideal for testing local APIs or self-signed HTTPS certificates. Use case: Running local development environments without needing valid SSL certificates. 3. chrome://flags/#ash-debug-shortcuts Activates developer keyboard shortcuts in Chrome OS. Great for debugging UI components, window managers, or testing multiple screen setups in dev environments. Use case: Chrome OS app development and layout testing on Chrome devices. 4. chrome://flags/#enable-command-line-on-non-rooted-devices This flag enables command-line access on non-rooted Android devices, facilitating debugging for mobile web developers using remote debugging or ADB. Use case: Simulating mobile interactions and terminal access in development workflows.","title":"Chrome OS Instructions"},{"location":"landing.html#history","text":"As an elementary school technology teacher, TinkerCAD provided easy to use on-ramps for students as young as 2nd grade. I spent the 23/24 school year teaching with TinkerCAD and found myself increasingly upset by the limitations and constraints of TinkerCAD. First and foremost, the fact of the CAD models sources being entirely unavailable. The \"Tinkercad source\" is actually entries in the Autodesk servers database. With no option to access those actual sources, students are tied entirely to the tinkercad website. The first real problem came when a student made a model in 5th grade that was so complex that the Tinkercad site crashed. The model was not recoverable, and the student that had done all of that extra work to add detail to his model lost everything. This experience started me thinking about how this could be made better for the students. The next major problem came when another student wanted to do CAD work on her ride home (which due to bus schedules took over an hour each day). She wanted to keep designing things, but without an internet connection she was unable to do any work. Finally i began to contemplate the pedagogical damage being done by teaching students a skill that is only accessible to them as mediated by a company. I began to feel a deep sense of unease that the skills of my students were increasingly being trapped behind a paywall. My solution was to make a locally installed application, that used an open file format that is stored locally on the disk, and that had access to the full resources of the computer the application was running on. In July 2024 I began work in earnest on CaDoodle. In April 2025 I hit a level of feature completeness to open it up for Beta testing.","title":"History"},{"location":"tutorial/AddNewExampleObjects.html","text":"I Absolutely want to have folks add more example shapes! The shapes pallet is defined by the contents of this repo: https://github.com/CommonWealthRobotics/CaDoodle-ShapesPalet-Content and cloned into ~/Documents/CaDoodle-workspace/gitcache/github.com/CommonWealthRobotics/CaDoodle-ShapesPalet-Content/ If you wanted to experiment, you can modify the existing .json files, or create your own to make a new menu item. Just close CaDoodle and open it up again to see your changes. The lines in the json \"Cube\":{ \"git\":\" https://github.com/madhephaestus/CaDoodle-Example-Objects.git \", \"file\":\"cube.groovy\", \"order\":\"2\" }, Is the URL to the git location of the file, and the file ke is the location of that file within the repository. The file can be any type supported for import. The order term is where the button should be in the grid of buttons. In the case of files you would like the uer to edit, just add the key: \"copyFile\":true This will make a copy of the source file into the users directory and provide an editor button in the UI for the user to edit the file. If you make a blender file you wan the user to sculpt on, then you would use that flag. If you would like to add your example shapes to the whole community, make a pull request with your updated https://github.com/CommonWealthRobotics/CaDoodle-ShapesPalet-Content Once I merge your PR, that object will be available to the whole community as an example object. Supported file types are: Doodle files (CaDoodle native file format) BowlerStudio scripted cad (Groovy) FreeCAD files Blender Files Inkscape SVG's (where all objects are paths) for extrusion Inkscape SCG's as sweep inputs (rings, threads, spirals) OpenSCAD files (you need to wrap it in a groovy file to expose the parametrics) STL files OBJ Files","title":"HOWTO Add new examples"},{"location":"tutorial/CSGServer.html","text":"CaDoodle supports running a remote server that will process the compute/ram heave operations and return the result into your running application. 0 Functionality When a client is connected to a server, then all CSG operations in the application will be tested for size, and off-loaded if the Operation is on more than 200 polygons. 1. Setup the Server On the server you will need: BowlerStudio.jar v3.10.3+ Java17 JDK+JFX A file containing valid API keys (In the tutorial it will be called File.txt) JAVA_HOME configured to point towards the JVM installed Using the auto-updater is not recommended for server use. 2. Run the server Assuming JAVA_HOME is set to the java installation Assuming File.txt is in the current directory and contains the API keys Assuming BowlerStudio.jar is in the current directory Assuming this server will run on the default port of 3742 $JAVA_HOME/bin/java -Dprism.forceGPU=true -XX:MaxRAMPercentage=90.0 --add-exports javafx.graphics/com.sun.javafx.css=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control.behavior=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control=ALL-UNNAMED --add-exports javafx.base/com.sun.javafx.event=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control.skin.resources=ALL-UNNAMED --add-exports javafx.graphics/com.sun.javafx.util=ALL-UNNAMED --add-exports javafx.graphics/com.sun.javafx.scene.input=ALL-UNNAMED --add-opens javafx.graphics/javafx.scene=ALL-UNNAMED -jar BowlerStudio.jar -csgserver /opt/File.txt 3742 Server launch script git clone https://github.com/CommonWealthRobotics/CSGServerScripts.git cd CSGServerScripts bash launch.sh /opt/File.txt 3742 Docker Put your API keys in /opt/File.txt and populate the file with API keys. To compile the image from the dockerfile: sudo bash docker-launch.sh or install the Dockerfile and Docker Compose files as needed. To just run the server, add the docker-compose.yml to your server and it will load the latest image from dockerhub. 3. Connect to the server For BowlerStudio scripts add this line to your code: CSGClient.start(\"127.0.0.1\", 3742, new File(\"/opt/File.txt\")); 3.1 Configure client By default the client will only off-load CSG operations that are more than 200 polygons. To configure this call: // Set a low number to ensure the Server is used. this defaults to 200 CSG.setMinPolygonsForOffloading(4); 3.2 Close the client When you are done running with a client, you can close it by calling: CSGClient,close() ` `","title":"CSG Server"},{"location":"tutorial/CSGServer.html#0-functionality","text":"When a client is connected to a server, then all CSG operations in the application will be tested for size, and off-loaded if the Operation is on more than 200 polygons.","title":"0 Functionality"},{"location":"tutorial/CSGServer.html#1-setup-the-server","text":"On the server you will need: BowlerStudio.jar v3.10.3+ Java17 JDK+JFX A file containing valid API keys (In the tutorial it will be called File.txt) JAVA_HOME configured to point towards the JVM installed Using the auto-updater is not recommended for server use.","title":"1. Setup the Server"},{"location":"tutorial/CSGServer.html#2-run-the-server","text":"Assuming JAVA_HOME is set to the java installation Assuming File.txt is in the current directory and contains the API keys Assuming BowlerStudio.jar is in the current directory Assuming this server will run on the default port of 3742 $JAVA_HOME/bin/java -Dprism.forceGPU=true -XX:MaxRAMPercentage=90.0 --add-exports javafx.graphics/com.sun.javafx.css=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control.behavior=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control=ALL-UNNAMED --add-exports javafx.base/com.sun.javafx.event=ALL-UNNAMED --add-exports javafx.controls/com.sun.javafx.scene.control.skin.resources=ALL-UNNAMED --add-exports javafx.graphics/com.sun.javafx.util=ALL-UNNAMED --add-exports javafx.graphics/com.sun.javafx.scene.input=ALL-UNNAMED --add-opens javafx.graphics/javafx.scene=ALL-UNNAMED -jar BowlerStudio.jar -csgserver /opt/File.txt 3742","title":"2. Run the server"},{"location":"tutorial/CSGServer.html#server-launch-script","text":"git clone https://github.com/CommonWealthRobotics/CSGServerScripts.git cd CSGServerScripts bash launch.sh /opt/File.txt 3742","title":"Server launch script"},{"location":"tutorial/CSGServer.html#docker","text":"Put your API keys in /opt/File.txt and populate the file with API keys. To compile the image from the dockerfile: sudo bash docker-launch.sh or install the Dockerfile and Docker Compose files as needed. To just run the server, add the docker-compose.yml to your server and it will load the latest image from dockerhub.","title":"Docker"},{"location":"tutorial/CSGServer.html#3-connect-to-the-server","text":"For BowlerStudio scripts add this line to your code: CSGClient.start(\"127.0.0.1\", 3742, new File(\"/opt/File.txt\"));","title":"3. Connect to the server"},{"location":"tutorial/CSGServer.html#31-configure-client","text":"By default the client will only off-load CSG operations that are more than 200 polygons. To configure this call: // Set a low number to ensure the Server is used. this defaults to 200 CSG.setMinPolygonsForOffloading(4);","title":"3.1 Configure client"},{"location":"tutorial/CSGServer.html#32-close-the-client","text":"When you are done running with a client, you can close it by calling: CSGClient,close() ` `","title":"3.2 Close the client"},{"location":"tutorial/getting-started.html","text":"Getting Started Overview CaDoodle works with .doodle files. These files are stored on your local machine. They are created and accessed from the CaDoodle Dashboard. Creating your first shape Each new .doodle file launches as a clear workspace with a shape panel on the right side. To add a shape to your workspace, click on the shape in the panel. Clicking on the shape will place the shape on the workspace and select the shape. A shape customization menu appears when shapes are selected. The shape customization menu allows you to make changes to basic shapes like adding chamfers, adjusting the number of sides, and more.","title":"Getting Started"},{"location":"tutorial/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"tutorial/getting-started.html#overview","text":"CaDoodle works with .doodle files. These files are stored on your local machine. They are created and accessed from the CaDoodle Dashboard.","title":"Overview"},{"location":"tutorial/getting-started.html#creating-your-first-shape","text":"Each new .doodle file launches as a clear workspace with a shape panel on the right side. To add a shape to your workspace, click on the shape in the panel. Clicking on the shape will place the shape on the workspace and select the shape. A shape customization menu appears when shapes are selected. The shape customization menu allows you to make changes to basic shapes like adding chamfers, adjusting the number of sides, and more.","title":"Creating your first shape"},{"location":"tutorial/where-are-my-files.html","text":"Where are my Files When CaDoodle is installed it is just an auto-updater. The updater will download the correct JVM, the current application JAR and all of the example objects on the first time it loads. that means that CaDoodle needs the Internet active for the first time it opens, or you need to copy these files from a working CaDoodle application to get it to work on an air-gapped machine. Once these files are downloaded, then CaDoodle will work without any Internet access whatsoever. Linux Application and plugins are in: ~/bin/CaDoodle-ApplicationInstall and ~/bin/BowlerStudioInstall User files and example models are in: ~/Documents/CaDoodle-workspace MacOS Application and plugins are in ~/bin/CaDoodle-ApplicationInstall and ~/bin/BowlerStudioInstall User files and example models are in: ~/Documents/BowlerLauncher/CaDoodle-workspace Windows Application and plugins are in ~\\bin\\CaDoodle-ApplicationInstall and ~\\bin\\BowlerStudioInstall User files and example models are in: ~\\Documents\\CaDoodle-workspace","title":"Where Are My Files"},{"location":"tutorial/where-are-my-files.html#where-are-my-files","text":"When CaDoodle is installed it is just an auto-updater. The updater will download the correct JVM, the current application JAR and all of the example objects on the first time it loads. that means that CaDoodle needs the Internet active for the first time it opens, or you need to copy these files from a working CaDoodle application to get it to work on an air-gapped machine. Once these files are downloaded, then CaDoodle will work without any Internet access whatsoever.","title":"Where are my Files"},{"location":"tutorial/where-are-my-files.html#linux","text":"Application and plugins are in: ~/bin/CaDoodle-ApplicationInstall and ~/bin/BowlerStudioInstall User files and example models are in: ~/Documents/CaDoodle-workspace","title":"Linux"},{"location":"tutorial/where-are-my-files.html#macos","text":"Application and plugins are in ~/bin/CaDoodle-ApplicationInstall and ~/bin/BowlerStudioInstall User files and example models are in: ~/Documents/BowlerLauncher/CaDoodle-workspace","title":"MacOS"},{"location":"tutorial/where-are-my-files.html#windows","text":"Application and plugins are in ~\\bin\\CaDoodle-ApplicationInstall and ~\\bin\\BowlerStudioInstall User files and example models are in: ~\\Documents\\CaDoodle-workspace","title":"Windows"}]}